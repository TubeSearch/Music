<!DOCTYPE html>
<html lang="en">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SoundSync</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #1a0d2e 0%, #2d1b4e 50%, #3b0066 100%);
            color: #e0d0ff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .header {
            background: rgba(26, 13, 46, 0.9);
            backdrop-filter: blur(20px);
            padding: 1.5rem 2rem;
            border-bottom: 2px solid #6b46c1;
            box-shadow: 0 8px 32px rgba(107, 70, 193, 0.3);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .logo {
            font-size: 2.5rem;
            font-weight: bold;
            background: linear-gradient(45deg, #42cbf5, #00c3ff, #003b4d);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
            text-shadow: 0 0 30px rgba(168, 85, 247, 0.5);
        }

        .tagline {
            text-align: center;
            color: #c4b5fd;
            font-size: 1.1rem;
            margin-top: 0.5rem;
            opacity: 0.9;
        }

        .nav-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1rem;
            flex-wrap: wrap;
        }

        .nav-btn {
            background: rgba(168, 85, 247, 0.2);
            border: 1px solid #a855f7;
            color: #e0d0ff;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .nav-btn:hover, .nav-btn.active {
            background: rgba(168, 85, 247, 0.4);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(168, 85, 247, 0.3);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        .upload-section {
            background: rgba(45, 27, 78, 0.6);
            border-radius: 20px;
            padding: 2rem;
            margin-bottom: 3rem;
            border: 1px solid rgba(168, 85, 247, 0.3);
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .upload-area {
            border: 2px dashed #a855f7;
            border-radius: 15px;
            padding: 3rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.1) 0%, rgba(236, 72, 153, 0.1) 100%);
        }

        .upload-area:hover {
            border-color: #ec4899;
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.2) 0%, rgba(236, 72, 153, 0.2) 100%);
            transform: translateY(-2px);
        }

        .upload-icon {
            width: 120px;
            height: auto;
        }

        .input-group {
            margin: 1rem 0;
        }

        .input-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: #c4b5fd;
            font-weight: 500;
        }

        .input-group input {
            width: 100%;
            padding: 0.8rem;
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 10px;
            background: rgba(45, 27, 78, 0.8);
            color: #e0d0ff;
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }

        .input-group input:focus {
            outline: none;
            border-color: #a855f7;
            box-shadow: 0 0 0 3px rgba(168, 85, 247, 0.1);
        }

        .btn {
            background: linear-gradient(45deg, #a855f7, #ec4899);
            color: white;
            border: none;
            padding: 1rem 2rem;
            border-radius: 12px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(168, 85, 247, 0.4);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(168, 85, 247, 0.6);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: linear-gradient(45deg, #22c55e, #16a34a);
            box-shadow: 0 4px 15px rgba(34, 197, 94, 0.4);
        }

        .btn-secondary:hover {
            background: linear-gradient(45deg, #3ee07a, #29c35e);
            box-shadow: 0 8px 25px rgba(34, 197, 94, 0.6);
        }

        .songs-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-top: 2rem;
        }

        .song-card {
            background: rgba(45, 27, 78, 0.8);
            border-radius: 15px;
            padding: 1.5rem;
            border: 1px solid rgba(168, 85, 247, 0.2);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
        }

        .song-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(168, 85, 247, 0.3);
            border-color: #a855f7;
        }

        .song-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #a855f7;
            margin-bottom: 0.5rem;
        }

        .song-meta {
            color: #9ca3af;
            font-size: 0.9rem;
        }

        .delete-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: linear-gradient(45deg, #ef4444, #dc2626);
            color: white;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(239, 68, 68, 0.4);
            opacity: 0;
            transform: scale(0.8);
        }

        .song-card:hover .delete-btn {
            opacity: 1;
            transform: scale(1);
        }

        .delete-btn:hover {
            background: linear-gradient(45deg, #dc2626, #b91c1c);
            transform: scale(1.1);
            box-shadow: 0 4px 15px rgba(239, 68, 68, 0.6);
        }

        .add-to-playlist-btn {
            position: absolute;
            top: 10px;
            right: 50px;
            background: linear-gradient(45deg, #22c55e, #16a34a);
            color: white;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(34, 197, 94, 0.4);
            opacity: 0;
            transform: scale(0.8);
        }

        .song-card:hover .add-to-playlist-btn {
            opacity: 1;
            transform: scale(1);
        }

        .add-to-playlist-btn:hover {
            background: linear-gradient(45deg, #16a34a, #15803d);
            transform: scale(1.1);
            box-shadow: 0 4px 15px rgba(34, 197, 94, 0.6);
        }

        .player-section {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(26, 13, 46, 0.95);
            backdrop-filter: blur(20px);
            padding: 1rem 2rem;
            border-top: 2px solid #6b46c1;
            transform: translateY(100%);
            transition: transform 0.3s ease;
            z-index: 1000;
        }

        .player-section.active {
            transform: translateY(0);
        }

        .player-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
            max-width: 1200px;
            margin: 0 auto;
        }

        .play-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(45deg, #a855f7, #ec4899);
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .play-btn:hover {
            transform: scale(1.1);
        }

        .autoplay-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(34, 197, 94, 0.8);
            border: none;
            color: white;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .autoplay-btn:hover {
            transform: scale(1.1);
        }

        .autoplay-btn.active {
            background: linear-gradient(45deg, #22c55e, #16a34a);
            box-shadow: 0 0 20px rgba(34, 197, 94, 0.5);
        }

        .track-info {
            flex: 1;
            min-width: 0;
        }

        .track-title {
            color: #a855f7;
            font-weight: 600;
            margin-bottom: 0.25rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .waveform-container {
            width: 100%;
            height: 60px;
            background: rgba(45, 27, 78, 0.6);
            border-radius: 8px;
            position: relative;
            overflow: hidden;
            cursor: pointer;
        }

        .waveform {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1px;
            padding: 5px;
        }

        .waveform-bar {
            background: linear-gradient(to top, #a855f7, #ec4899);
            border-radius: 2px;
            transition: all 0.1s ease;
            min-width: 2px;
        }

        .waveform-bar.active {
            background: linear-gradient(to top, #1e40af, #3b82f6);
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.6);
        }

        .progress-overlay {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background: linear-gradient(90deg, 
                rgba(30, 64, 175, 0.3) 0%, 
                rgba(59, 130, 246, 0.1) 100%);
            transition: width 0.1s ease;
            border-radius: 8px;
        }

        .time-info {
            color: #9ca3af;
            font-size: 0.9rem;
            min-width: 100px;
            text-align: right;
        }

        .loading {
            text-align: center;
            color: #a855f7;
            font-size: 1.1rem;
            margin: 2rem 0;
        }

        .error {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid #ef4444;
            color: #fca5a5;
            padding: 1rem;
            border-radius: 10px;
            margin: 1rem 0;
        }

        .success {
            background: rgba(34, 197, 94, 0.1);
            border: 1px solid #22c55e;
            color: #86efac;
            padding: 1rem;
            border-radius: 10px;
            margin: 1rem 0;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            backdrop-filter: blur(5px);
        }

        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: rgba(45, 27, 78, 0.95);
            border-radius: 20px;
            padding: 2rem;
            border: 1px solid rgba(168, 85, 247, 0.3);
            backdrop-filter: blur(20px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .modal-title {
            font-size: 1.5rem;
            color: #a855f7;
            font-weight: 600;
        }

        .close-btn {
            background: none;
            border: none;
            color: #9ca3af;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.5rem;
            transition: color 0.3s ease;
        }

        .close-btn:hover {
            color: #e0d0ff;
        }

        .playlist-card {
            background: rgba(45, 27, 78, 0.8);
            border-radius: 15px;
            padding: 1.5rem;
            border: 1px solid rgba(168, 85, 247, 0.2);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            margin-bottom: 1rem;
        }

        .playlist-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(168, 85, 247, 0.3);
            border-color: #a855f7;
        }

        .playlist-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #a855f7;
            margin-bottom: 0.5rem;
        }

        .playlist-meta {
            color: #9ca3af;
            font-size: 0.9rem;
        }

        .playlist-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding: 1rem;
            background: rgba(45, 27, 78, 0.6);
            border-radius: 15px;
            border: 1px solid rgba(168, 85, 247, 0.3);
        }

        .back-btn {
            background: rgba(156, 163, 175, 0.2);
            border: 1px solid #9ca3af;
            color: #e0d0ff;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .back-btn:hover {
            background: rgba(156, 163, 175, 0.3);
            transform: translateY(-2px);
        }

        .playlist-actions {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .song-item {
            display: flex;
            align-items: center;
            padding: 1rem;
            background: rgba(45, 27, 78, 0.8);
            border-radius: 10px;
            margin-bottom: 0.5rem;
            border: 1px solid rgba(168, 85, 247, 0.2);
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .song-item:hover {
            background: rgba(168, 85, 247, 0.1);
            transform: translateX(5px);
        }

        .song-item.playing {
            border-color: #22c55e;
            background: rgba(34, 197, 94, 0.1);
        }

        .song-index {
            color: #9ca3af;
            font-weight: bold;
            min-width: 30px;
            margin-right: 1rem;
        }

        .song-details {
            flex: 1;
        }

        .song-item-title {
            color: #e0d0ff;
            font-weight: 500;
            margin-bottom: 0.25rem;
        }

        .song-item-meta {
            color: #9ca3af;
            font-size: 0.8rem;
        }

        .remove-from-playlist-btn {
            background: linear-gradient(45deg, #ef4444, #dc2626);
            color: white;
            border: none;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 0.7rem;
            font-weight: bold;
            transition: all 0.3s ease;
            opacity: 0.7;
        }

        .remove-from-playlist-btn:hover {
            opacity: 1;
            transform: scale(1.1);
        }

        .checkbox-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 10px;
            background: rgba(26, 13, 46, 0.5);
            padding: 1rem;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            padding: 0.5rem;
            border-radius: 5px;
            transition: background-color 0.2s ease;
            cursor: pointer;
        }

        .checkbox-item:hover {
            background: rgba(168, 85, 247, 0.1);
        }

        .checkbox-item input[type="checkbox"] {
            margin-right: 0.75rem;
            transform: scale(1.2);
        }

        .checkbox-item label {
            cursor: pointer;
            flex: 1;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .loading-pulse {
            animation: pulse 2s infinite;
        }

        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            
            .header {
                padding: 1rem;
            }
            
            .logo {
                font-size: 2rem;
            }
            
            .player-controls {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            .songs-grid {
                grid-template-columns: 1fr;
            }

            .nav-buttons {
                flex-direction: column;
                align-items: center;
            }

            .playlist-controls {
                flex-direction: column;
                gap: 1rem;
                align-items: stretch;
            }
        }
    </style>

    <div class="header">
        <h1 class="logo">SoundSync</h1>
        <div class="nav-buttons">
            <button class="nav-btn active" id="libraryBtn" onclick="showLibrary()">Music Library</button>
            <button class="nav-btn" id="playlistsBtn" onclick="showPlaylists()">Playlists</button>
            <button class="nav-btn btn-secondary" onclick="showCreatePlaylistModal()">+ Create Playlist</button>
        </div>
    </div>

    <div class="container">
        <!-- Upload Section -->
        <div class="upload-section" id="uploadSection">
            <div class="upload-area" onclick="document.getElementById('audioFile').click()">
            <img class="upload-icon" src="https://uploads.onecompiler.io/43hrj7rd3/43tm7xcmd/Screenshot_2025-08-13_150727-removebg-preview.png" alt="Upload Icon">
                <h3>Drop your audio files here or click to browse</h3>
                <p>MP3, WAV, OGG</p>
            </div>
            
            <input type="file" id="audioFile" accept="audio/*" style="display: none;">
            
            <div class="input-group">
                <label for="songTitle">Song Title</label>
                <input type="text" id="songTitle" placeholder="Enter song title...">
            </div>
            
            <button class="btn" id="uploadBtn" disabled>
                Upload Song
            </button>
        </div>

        <!-- Songs Container -->
        <div id="songsContainer">
            <div class="loading loading-pulse">Loading music library...</div>
        </div>

        <!-- Playlists Container -->
        <div id="playlistsContainer" style="display: none;">
            <div class="loading loading-pulse">Loading playlists...</div>
        </div>

        <!-- Playlist View Container -->
        <div id="playlistViewContainer" style="display: none;">
            <!-- Playlist content will be dynamically loaded here -->
        </div>
    </div>

    <!-- Player Section -->
    <div class="player-section" id="playerSection">
        <div class="player-controls">
            <button class="play-btn" id="playBtn">‚ñ∂Ô∏è</button>
            <button class="autoplay-btn" id="autoplayBtn" title="Toggle Autoplay" style="display: none;">üîÑ</button>
            <div class="track-info">
                <div class="track-title" id="currentTrackTitle">Select a song to play</div>
                <div class="waveform-container" id="waveformContainer">
                    <div class="progress-overlay" id="progressOverlay"></div>
                    <div class="waveform" id="waveform">
                        <!-- Waveform bars will be generated here -->
                    </div>
                </div>
            </div>
            <div class="time-info" id="timeInfo">0:00 / 0:00</div>
        </div>
        <audio id="audioPlayer" preload="metadata"></audio>
    </div>

    <!-- Create Playlist Modal -->
    <div class="modal" id="createPlaylistModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Create New Playlist</h3>
                <button class="close-btn" onclick="closeModal('createPlaylistModal')">&times;</button>
            </div>
            <div class="input-group">
                <label for="playlistName">Playlist Name</label>
                <input type="text" id="playlistName" placeholder="Enter playlist name...">
            </div>
            <div style="display: flex; gap: 1rem; justify-content: flex-end;">
                <button class="btn" style="background: #6b7280;" onclick="closeModal('createPlaylistModal')">Cancel</button>
                <button class="btn" onclick="createPlaylist()">Create Playlist</button>
            </div>
        </div>
    </div>

    <!-- Add to Playlist Modal -->
    <div class="modal" id="addToPlaylistModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Add to Playlist</h3>
                <button class="close-btn" onclick="closeModal('addToPlaylistModal')">&times;</button>
            </div>
            <div id="playlistCheckboxList" class="checkbox-list">
                <!-- Playlist checkboxes will be loaded here -->
            </div>
            <div style="display: flex; gap: 1rem; justify-content: flex-end; margin-top: 1rem;">
                <button class="btn" style="background: #6b7280;" onclick="closeModal('addToPlaylistModal')">Cancel</button>
                <button class="btn" onclick="addSongToSelectedPlaylists()">Add to Playlists</button>
            </div>
        </div>
    </div>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.22.1/firebase-app.js';
        import { getFirestore, collection, addDoc, getDocs, doc, onSnapshot, orderBy, query, deleteDoc, updateDoc, arrayUnion, arrayRemove, getDoc } from 'https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore.js';

        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyB_RmPGmYLZAl1IpOfKYXrJlJmAVHxYhik",
            authDomain: "music-13b62.firebaseapp.com",
            projectId: "music-13b62",
            storageBucket: "music-13b62.firebasestorage.app",
            messagingSenderId: "188109099327",
            appId: "1:188109099327:web:e6a64a19e6fb3cae48438a",
            measurementId: "G-RB3RMDVZJ2"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        // DOM elements
        const audioFile = document.getElementById('audioFile');
        const songTitle = document.getElementById('songTitle');
        const uploadBtn = document.getElementById('uploadBtn');
        const songsContainer = document.getElementById('songsContainer');
        const playlistsContainer = document.getElementById('playlistsContainer');
        const playlistViewContainer = document.getElementById('playlistViewContainer');
        const uploadSection = document.getElementById('uploadSection');
        const audioPlayer = document.getElementById('audioPlayer');
        const playBtn = document.getElementById('playBtn');
        const autoplayBtn = document.getElementById('autoplayBtn');
        const playerSection = document.getElementById('playerSection');
        const currentTrackTitle = document.getElementById('currentTrackTitle');
        const waveform = document.getElementById('waveform');
        const progressOverlay = document.getElementById('progressOverlay');
        const timeInfo = document.getElementById('timeInfo');
        const waveformContainer = document.getElementById('waveformContainer');
        const libraryBtn = document.getElementById('libraryBtn');
        const playlistsBtn = document.getElementById('playlistsBtn');

        // Global variables
        let currentSong = null;
        let isPlaying = false;
        let waveformData = [];
        let currentWaveformBars = [];
        let currentView = 'library'; // 'library', 'playlists', 'playlist'
        let currentPlaylist = null;
        let currentPlaylistSongs = [];
        let currentSongIndex = -1;
        let isAutoplay = false;
        let selectedSongForPlaylist = null;
        let allSongs = [];
        let allPlaylists = [];

        // Navigation functions
        window.showLibrary = () => {
            currentView = 'library';
            uploadSection.style.display = 'block';
            songsContainer.style.display = 'block';
            playlistsContainer.style.display = 'none';
            playlistViewContainer.style.display = 'none';
            autoplayBtn.style.display = 'none';
            
            libraryBtn.classList.add('active');
            playlistsBtn.classList.remove('active');
            
            loadSongs();
        };

        window.showPlaylists = () => {
            currentView = 'playlists';
            uploadSection.style.display = 'none';
            songsContainer.style.display = 'none';
            playlistsContainer.style.display = 'block';
            playlistViewContainer.style.display = 'none';
            autoplayBtn.style.display = 'none';
            
            libraryBtn.classList.remove('active');
            playlistsBtn.classList.add('active');
            
            loadPlaylists();
        };

        window.showPlaylistView = async (playlistId, playlistName) => {
            currentView = 'playlist';
            currentPlaylist = { id: playlistId, name: playlistName };
            uploadSection.style.display = 'none';
            songsContainer.style.display = 'none';
            playlistsContainer.style.display = 'none';
            playlistViewContainer.style.display = 'block';
            autoplayBtn.style.display = 'block';
            
            await loadPlaylistView(playlistId, playlistName);
        };

        // Modal functions
        window.showCreatePlaylistModal = () => {
            document.getElementById('createPlaylistModal').classList.add('active');
            document.getElementById('playlistName').focus();
        };

        window.closeModal = (modalId) => {
            document.getElementById(modalId).classList.remove('active');
            if (modalId === 'createPlaylistModal') {
                document.getElementById('playlistName').value = '';
            }
        };

        window.createPlaylist = async () => {
            const name = document.getElementById('playlistName').value.trim();
            if (!name) {
                showMessage('Please enter a playlist name', 'error');
                return;
            }

            try {
                await addDoc(collection(db, 'playlists'), {
                    name: name,
                    songs: [],
                    createdAt: new Date(),
                    updatedAt: new Date()
                });

                showMessage('Playlist created successfully!', 'success');
                closeModal('createPlaylistModal');
                
                if (currentView === 'playlists') {
                    loadPlaylists();
                }
            } catch (error) {
                console.error('Error creating playlist:', error);
                showMessage('Failed to create playlist. Please try again.', 'error');
            }
        };

        window.showAddToPlaylistModal = async (songId, songTitle) => {
            selectedSongForPlaylist = { id: songId, title: songTitle };
            
            // Load playlists for checkboxes
            const playlistCheckboxList = document.getElementById('playlistCheckboxList');
            playlistCheckboxList.innerHTML = '<div class="loading">Loading playlists...</div>';
            
            try {
                const q = query(collection(db, 'playlists'), orderBy('name'));
                const snapshot = await getDocs(q);
                
                if (snapshot.empty) {
                    playlistCheckboxList.innerHTML = '<p style="color: #9ca3af; text-align: center;">No playlists found. Create one first!</p>';
                } else {
                    let checkboxHTML = '';
                    snapshot.forEach((doc) => {
                        const playlist = doc.data();
                        const isInPlaylist = playlist.songs && playlist.songs.includes(songId);
                        checkboxHTML += `
                            <div class="checkbox-item">
                                <input type="checkbox" id="playlist_${doc.id}" value="${doc.id}" ${isInPlaylist ? 'checked' : ''}>
                                <label for="playlist_${doc.id}">${playlist.name}</label>
                            </div>
                        `;
                    });
                    playlistCheckboxList.innerHTML = checkboxHTML;
                }
                
                document.getElementById('addToPlaylistModal').classList.add('active');
            } catch (error) {
                console.error('Error loading playlists:', error);
                playlistCheckboxList.innerHTML = '<p style="color: #ef4444; text-align: center;">Failed to load playlists</p>';
            }
        };

        window.addSongToSelectedPlaylists = async () => {
            if (!selectedSongForPlaylist) {
                showMessage('No song selected', 'error');
                return;
            }

            const checkboxes = document.querySelectorAll('#playlistCheckboxList input[type="checkbox"]');
            if (checkboxes.length === 0) {
                showMessage('No playlists available', 'error');
                return;
            }

            const updates = [];
            let addedToCount = 0;
            let removedFromCount = 0;

            for (let checkbox of checkboxes) {
                const playlistId = checkbox.value;
                const isChecked = checkbox.checked;
                
                try {
                    const playlistRef = doc(db, 'playlists', playlistId);
                    const playlistDoc = await getDoc(playlistRef);
                    
                    if (!playlistDoc.exists()) {
                        console.error(`Playlist ${playlistId} not found`);
                        continue;
                    }
                    
                    const currentSongs = playlistDoc.data().songs || [];
                    
                    if (isChecked && !currentSongs.includes(selectedSongForPlaylist.id)) {
                        updates.push(updateDoc(playlistRef, {
                            songs: arrayUnion(selectedSongForPlaylist.id),
                            updatedAt: new Date()
                        }));
                        addedToCount++;
                    } else if (!isChecked && currentSongs.includes(selectedSongForPlaylist.id)) {
                        updates.push(updateDoc(playlistRef, {
                            songs: arrayRemove(selectedSongForPlaylist.id),
                            updatedAt: new Date()
                        }));
                        removedFromCount++;
                    }
                } catch (error) {
                    console.error('Error checking playlist:', error);
                }
            }

            if (updates.length === 0) {
                showMessage('No changes to make', 'success');
                closeModal('addToPlaylistModal');
                return;
            }

            try {
                await Promise.all(updates);
                
                let message = '';
                if (addedToCount > 0 && removedFromCount > 0) {
                    message = `"${selectedSongForPlaylist.title}" added to ${addedToCount} and removed from ${removedFromCount} playlists`;
                } else if (addedToCount > 0) {
                    message = `"${selectedSongForPlaylist.title}" added to ${addedToCount} playlist${addedToCount > 1 ? 's' : ''}`;
                } else if (removedFromCount > 0) {
                    message = `"${selectedSongForPlaylist.title}" removed from ${removedFromCount} playlist${removedFromCount > 1 ? 's' : ''}`;
                }
                
                showMessage(message, 'success');
                closeModal('addToPlaylistModal');
                
                // Refresh current view if in playlist
                if (currentView === 'playlist' && currentPlaylist) {
                    loadPlaylistView(currentPlaylist.id, currentPlaylist.name);
                }
            } catch (error) {
                console.error('Error updating playlists:', error);
                showMessage('Failed to update playlists. Please try again.', 'error');
            }
        };

        // Playlist functions
        window.deletePlaylist = async (playlistId, playlistName, event) => {
            event.stopPropagation();
            
            if (!confirm(`Are you sure you want to delete the playlist "${playlistName}"? This cannot be undone.`)) {
                return;
            }

            try {
                await deleteDoc(doc(db, 'playlists', playlistId));
                showMessage(`Playlist "${playlistName}" deleted successfully!`, 'success');
                
                if (currentView === 'playlists') {
                    loadPlaylists();
                } else if (currentView === 'playlist' && currentPlaylist && currentPlaylist.id === playlistId) {
                    showPlaylists();
                }
            } catch (error) {
                console.error('Error deleting playlist:', error);
                showMessage(`Failed to delete playlist "${playlistName}". Please try again.`, 'error');
            }
        };

        window.removeSongFromPlaylist = async (songId, event) => {
            event.stopPropagation();
            
            if (!currentPlaylist) return;

            try {
                const playlistRef = doc(db, 'playlists', currentPlaylist.id);
                await updateDoc(playlistRef, {
                    songs: arrayRemove(songId),
                    updatedAt: new Date()
                });

                loadPlaylistView(currentPlaylist.id, currentPlaylist.name);
            } catch (error) {
                console.error('Error removing song from playlist:', error);
                showMessage('Failed to remove song from playlist. Please try again.', 'error');
            }
        };

        window.playPlaylistSong = (index) => {
            if (index >= 0 && index < currentPlaylistSongs.length) {
                currentSongIndex = index;
                const song = currentPlaylistSongs[index];
                playSong(song.id, song.title, song.isChunked || false);
            }
        };

        // Load functions
        async function loadPlaylists() {
            try {
                const q = query(collection(db, 'playlists'), orderBy('updatedAt', 'desc'));
                
                onSnapshot(q, async (snapshot) => {
                    allPlaylists = [];
                    const playlistPromises = [];

                    snapshot.forEach((doc) => {
                        const playlist = { id: doc.id, ...doc.data() };
                        allPlaylists.push(playlist);
                        playlistPromises.push(playlist);
                    });

                    displayPlaylists(allPlaylists);
                });

            } catch (error) {
                console.error('Error loading playlists:', error);
                playlistsContainer.innerHTML = '<div class="error">Failed to load playlists</div>';
            }
        }

        function displayPlaylists(playlists) {
            if (playlists.length === 0) {
                playlistsContainer.innerHTML = `
                    <div style="text-align: center; color: #9ca3af; margin: 2rem 0;">
                        <h3>No playlists created yet</h3>
                        <p>Create your first playlist to organize your music!</p>
                    </div>
                `;
                return;
            }

            const playlistsHTML = playlists.map(playlist => `
                <div class="playlist-card" onclick="showPlaylistView('${playlist.id}', '${playlist.name}')">
                    <button class="delete-btn" onclick="deletePlaylist('${playlist.id}', '${playlist.name}', event)" title="Delete Playlist">
                        ‚úï
                    </button>
                    <div class="playlist-title">${playlist.name}</div>
                    <div class="playlist-meta">
                        ${playlist.songs ? playlist.songs.length : 0} songs
                        <br>
                        ${formatDate(playlist.updatedAt.toDate())}
                    </div>
                </div>
            `).join('');

            playlistsContainer.innerHTML = `
                <h2 style="color: #a855f7; margin-bottom: 1rem;">Your Playlists</h2>
                ${playlistsHTML}
            `;
        }

        async function loadPlaylistView(playlistId, playlistName) {
            try {
                playlistViewContainer.innerHTML = '<div class="loading loading-pulse">Loading playlist...</div>';

                const playlistDoc = await getDoc(doc(db, 'playlists', playlistId));
                if (!playlistDoc.exists()) {
                    playlistViewContainer.innerHTML = '<div class="error">Playlist not found</div>';
                    return;
                }

                const playlist = playlistDoc.data();
                const songIds = playlist.songs || [];

                // Get all songs to match with playlist
                const songsQuery = query(collection(db, 'songs'), orderBy('uploadedAt', 'desc'));
                const songsSnapshot = await getDocs(songsQuery);
                
                currentPlaylistSongs = [];
                songsSnapshot.forEach((doc) => {
                    if (songIds.includes(doc.id)) {
                        currentPlaylistSongs.push({ id: doc.id, ...doc.data() });
                    }
                });

                // Sort playlist songs by their order in the playlist
                currentPlaylistSongs.sort((a, b) => {
                    const indexA = songIds.indexOf(a.id);
                    const indexB = songIds.indexOf(b.id);
                    return indexA - indexB;
                });

                displayPlaylistView(playlistName, currentPlaylistSongs);

            } catch (error) {
                console.error('Error loading playlist view:', error);
                playlistViewContainer.innerHTML = '<div class="error">Failed to load playlist</div>';
            }
        }

        function displayPlaylistView(playlistName, songs) {
            let songsHTML = '';
            
            if (songs.length === 0) {
                songsHTML = `
                    <div style="text-align: center; color: #9ca3af; margin: 2rem 0;">
                        <h3>This playlist is empty</h3>
                        <p>Go to your music library and add some songs!</p>
                    </div>
                `;
            } else {
                songsHTML = songs.map((song, index) => `
                    <div class="song-item ${currentSongIndex === index ? 'playing' : ''}" onclick="playPlaylistSong(${index})">
                        <div class="song-index">${index + 1}</div>
                        <div class="song-details">
                            <div class="song-item-title">${song.title}</div>
                            <div class="song-item-meta">
                                ${formatFileSize(song.size)} ‚Ä¢ ${formatDuration(song.duration)}
                            </div>
                        </div>
                        <button class="remove-from-playlist-btn" onclick="removeSongFromPlaylist('${song.id}', event)" title="Remove from playlist">
                            ‚úï
                        </button>
                    </div>
                `).join('');
            }

            playlistViewContainer.innerHTML = `
                <div class="playlist-controls">
                    <button class="back-btn" onclick="showPlaylists()">‚Üê Back to Playlists</button>
                    <div class="playlist-actions">
                        <h2 style="color: #a855f7; margin: 0;">${playlistName}</h2>
                        <span style="color: #9ca3af;">${songs.length} songs</span>
                    </div>
                </div>
                ${songsHTML}
            `;
        }

        // File input change handler
        audioFile.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                uploadBtn.disabled = false;
                if (!songTitle.value) {
                    songTitle.value = file.name.replace(/\.[^/.]+$/, "");
                }
            }
        });

        // Delete song and all related chunks
        async function deleteSong(songId, songTitle, event) {
            event.stopPropagation(); 
            
            if (!confirm(`Are you sure you want to delete "${songTitle}"? This will also remove it from all playlists. This cannot be undone.`)) {
                return;
            }

            try {
                showMessage(`Deleting "${songTitle}"...`, 'error');

                // Remove from all playlists first
                const playlistsQuery = query(collection(db, 'playlists'));
                const playlistsSnapshot = await getDocs(playlistsQuery);
                const playlistUpdates = [];

                playlistsSnapshot.forEach((playlistDoc) => {
                    const playlist = playlistDoc.data();
                    if (playlist.songs && playlist.songs.includes(songId)) {
                        playlistUpdates.push(
                            updateDoc(doc(db, 'playlists', playlistDoc.id), {
                                songs: arrayRemove(songId),
                                updatedAt: new Date()
                            })
                        );
                    }
                });

                await Promise.all(playlistUpdates);

                // Delete all chunks (if it's a chunked song)
                const chunksSnapshot = await getDocs(collection(db, `songs/${songId}/chunks`));
                const deleteChunkPromises = [];
                
                chunksSnapshot.forEach((chunkDoc) => {
                    deleteChunkPromises.push(deleteDoc(doc(db, `songs/${songId}/chunks`, chunkDoc.id)));
                });

                await Promise.all(deleteChunkPromises);

                // Delete the main song document
                await deleteDoc(doc(db, 'songs', songId));

                showMessage(`"${songTitle}" deleted successfully!`, 'success');

                // If this was the currently playing song, stop it
                if (currentSong && currentTrackTitle.textContent === songTitle) {
                    audioPlayer.pause();
                    audioPlayer.src = '';
                    playerSection.classList.remove('active');
                    currentSong = null;
                    isPlaying = false;
                    playBtn.textContent = '‚ñ∂Ô∏è';
                    autoplayBtn.style.display = 'none';
                }

                // Refresh current view
                if (currentView === 'playlist' && currentPlaylist) {
                    loadPlaylistView(currentPlaylist.id, currentPlaylist.name);
                }

            } catch (error) {
                console.error('Delete error:', error);
                showMessage(`Failed to delete "${songTitle}". Please try again.`, 'error');
            }
        }

        window.deleteSong = deleteSong;

        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => resolve(reader.result);
                reader.onerror = error => reject(error);
            });
        }

        // Split base64 data into chunks for Firestore
        function chunkBase64Data(base64Data, chunkSize = 900000) { // ~900KB chunks
            const chunks = [];
            const dataOnly = base64Data.split(',')[1]; // Remove data URL prefix
            const mimeType = base64Data.split(',')[0]; // Keep the data URL prefix
            
            for (let i = 0; i < dataOnly.length; i += chunkSize) {
                chunks.push(dataOnly.substring(i, i + chunkSize));
            }
            
            return { chunks, mimeType };
        }

        // Reconstruct base64 data from chunks
        async function reconstructBase64FromChunks(songId) {
            try {
                const songDoc = await getDocs(query(collection(db, 'songs'), 
                    orderBy('uploadedAt', 'desc')));
                
                let mainSong = null;
                songDoc.forEach(doc => {
                    if (doc.id === songId) {
                        mainSong = { id: doc.id, ...doc.data() };
                    }
                });

                if (!mainSong || !mainSong.totalChunks) {
                    throw new Error('Song metadata not found');
                }

                const chunks = [];
                const chunksSnapshot = await getDocs(collection(db, `songs/${songId}/chunks`));
                chunksSnapshot.forEach(doc => {
                    const data = doc.data();
                    chunks[data.index] = data.chunk;
                });

                const fullData = chunks.join('');
                return `${mainSong.mimeTypePrefix},${fullData}`;

            } catch (error) {
                console.error('Error reconstructing audio data:', error);
                throw error;
            }
        }

        // Upload functionality
        uploadBtn.addEventListener('click', async () => {
            const file = audioFile.files[0];
            const title = songTitle.value.trim();

            if (!file || !title) {
                showMessage('Please select a file and enter a title', 'error');
                return;
            }

            uploadBtn.disabled = true;
            uploadBtn.textContent = 'Converting & Uploading...';

            try {
                const base64Data = await fileToBase64(file);
                const duration = await getAudioDuration(file);
                const { chunks, mimeType } = chunkBase64Data(base64Data);

                const songDocRef = await addDoc(collection(db, 'songs'), {
                    title: title,
                    filename: file.name,
                    size: file.size,
                    mimeType: file.type,
                    mimeTypePrefix: mimeType,
                    uploadedAt: new Date(),
                    duration: duration,
                    totalChunks: chunks.length,
                    isChunked: true
                });

                const chunkPromises = chunks.map((chunk, index) => 
                    addDoc(collection(db, `songs/${songDocRef.id}/chunks`), {
                        index: index,
                        chunk: chunk,
                        uploadedAt: new Date()
                    })
                );

                await Promise.all(chunkPromises);

                showMessage(`Song uploaded successfully in ${chunks.length} chunks!`, 'success');
                
                audioFile.value = '';
                songTitle.value = '';
                uploadBtn.disabled = true;
                uploadBtn.textContent = 'Upload Song';

            } catch (error) {
                console.error('Upload error:', error);
                showMessage('Failed to upload song. Please try again.', 'error');
                uploadBtn.disabled = false;
                uploadBtn.textContent = 'Upload Song';
            }
        });

        function getAudioDuration(file) {
            return new Promise((resolve) => {
                const audio = document.createElement('audio');
                audio.preload = 'metadata';
                audio.onloadedmetadata = () => {
                    resolve(audio.duration);
                };
                audio.src = URL.createObjectURL(file);
            });
        }

        async function loadSongs() {
            try {
                const q = query(collection(db, 'songs'), orderBy('uploadedAt', 'desc'));
                
                onSnapshot(q, (snapshot) => {
                    allSongs = [];
                    snapshot.forEach((doc) => {
                        allSongs.push({ id: doc.id, ...doc.data() });
                    });
                    displaySongs(allSongs);
                });

            } catch (error) {
                console.error('Error loading songs:', error);
                songsContainer.innerHTML = '<div class="error">Failed to load songs</div>';
            }
        }

        function displaySongs(songs) {
            if (songs.length === 0) {
                songsContainer.innerHTML = `
                    <div style="text-align: center; color: #9ca3af; margin: 2rem 0;">
                        <h3>No songs uploaded yet</h3>
                        <p>Upload your first song to get started!</p>
                    </div>
                `;
                return;
            }

            const songsGrid = songs.map(song => `
                <div class="song-card" onclick="playSong('${song.id}', '${song.title}', ${song.isChunked || false})">
                    <button class="delete-btn" onclick="deleteSong('${song.id}', '${song.title}', event)" title="Delete Song">
                        ‚úï
                    </button>
                    <button class="add-to-playlist-btn" onclick="showAddToPlaylistModal('${song.id}', '${song.title.replace(/'/g, "\\'")}', event)" title="Add to Playlist">
                        +
                    </button>
                    <div class="song-title">${song.title}</div>
                    <div class="song-meta">
                        ${formatFileSize(song.size)} ‚Ä¢ ${formatDuration(song.duration)}
                        <br>
                        ${formatDate(song.uploadedAt.toDate())}
                        ${song.isChunked ? ` ‚Ä¢ ${song.totalChunks} chunks` : ''}
                    </div>
                </div>
            `).join('');

            songsContainer.innerHTML = `
                <h2 style="color: #a855f7; margin-bottom: 1rem;">Music Library</h2>
                <div class="songs-grid">${songsGrid}</div>
            `;
        }

        // Add event handler for add to playlist button
        window.showAddToPlaylistModal = async (songId, songTitle, event) => {
            event.stopPropagation();
            selectedSongForPlaylist = { id: songId, title: songTitle };
            
            // Load playlists for checkboxes
            const playlistCheckboxList = document.getElementById('playlistCheckboxList');
            playlistCheckboxList.innerHTML = '<div class="loading">Loading playlists...</div>';
            
            try {
                const q = query(collection(db, 'playlists'), orderBy('name'));
                const snapshot = await getDocs(q);
                
                if (snapshot.empty) {
                    playlistCheckboxList.innerHTML = '<p style="color: #9ca3af; text-align: center;">No playlists found. Create one first!</p>';
                } else {
                    let checkboxHTML = '';
                    snapshot.forEach((doc) => {
                        const playlist = doc.data();
                        const isInPlaylist = playlist.songs && playlist.songs.includes(songId);
                        checkboxHTML += `
                            <div class="checkbox-item">
                                <input type="checkbox" id="playlist_${doc.id}" value="${doc.id}" ${isInPlaylist ? 'checked' : ''}>
                                <label for="playlist_${doc.id}">${playlist.name}</label>
                            </div>
                        `;
                    });
                    playlistCheckboxList.innerHTML = checkboxHTML;
                }
                
                document.getElementById('addToPlaylistModal').classList.add('active');
            } catch (error) {
                console.error('Error loading playlists:', error);
                playlistCheckboxList.innerHTML = '<p style="color: #ef4444; text-align: center;">Failed to load playlists</p>';
                document.getElementById('addToPlaylistModal').classList.add('active');
            }
        };

        // Play song
        window.playSong = async (songIdOrData, title, isChunked = false) => {
            try {
                currentTrackTitle.textContent = `Loading: ${title}`;
                playerSection.classList.add('active');
                
                let audioData;
                
                if (isChunked) {
                    currentTrackTitle.textContent = `Reconstructing: ${title}`;
                    audioData = await reconstructBase64FromChunks(songIdOrData);
                } else {
                    audioData = songIdOrData;
                }
                
                currentSong = { audioData, title };
                currentTrackTitle.textContent = title;
                audioPlayer.src = audioData;
                
                audioPlayer.addEventListener('loadeddata', generateWaveform, { once: true });
                
                await audioPlayer.play();
                isPlaying = true;
                playBtn.textContent = '‚è∏Ô∏è';
                
                // Show autoplay button if in playlist view
                if (currentView === 'playlist') {
                    autoplayBtn.style.display = 'block';
                }
                
            } catch (error) {
                console.error('Playback error:', error);
                showMessage('Failed to play audio. The file might be corrupted.', 'error');
                currentTrackTitle.textContent = 'Error loading song';
            }
        };

        // Autoplay functionality
        autoplayBtn.addEventListener('click', () => {
            isAutoplay = !isAutoplay;
            autoplayBtn.classList.toggle('active', isAutoplay);
            autoplayBtn.title = isAutoplay ? 'Autoplay: ON' : 'Autoplay: OFF';
            
            if (isAutoplay) {
                showMessage('Autoplay enabled', 'success');
            } else {
                showMessage('Autoplay disabled', 'success');
            }
        });

        // Audio ended - autoplay next song if enabled and in playlist
        audioPlayer.addEventListener('ended', () => {
            isPlaying = false;
            playBtn.textContent = '‚ñ∂Ô∏è';
            progressOverlay.style.width = '0%';
            currentWaveformBars.forEach(bar => bar.classList.remove('active'));
            
            if (isAutoplay && currentView === 'playlist' && currentPlaylistSongs.length > 0) {
                const nextIndex = currentSongIndex + 1;
                if (nextIndex < currentPlaylistSongs.length) {
                    setTimeout(() => {
                        playPlaylistSong(nextIndex);
                    }, 1000); // 1 second delay before next song
                } else {
                    // Reached end of playlist
                    currentSongIndex = -1;
                    showMessage('End of playlist reached', 'success');
                }
            }
        });

        // Generate waveform visualization
        async function generateWaveform() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                const base64Data = audioPlayer.src.split(',')[1];
                const binaryString = window.atob(base64Data);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                const arrayBuffer = bytes.buffer;
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                
                const channelData = audioBuffer.getChannelData(0);
                const barCount = 200;
                const samplesPerBar = Math.floor(channelData.length / barCount);
                waveformData = [];
                
                for (let i = 0; i < barCount; i++) {
                    let sum = 0;
                    let start = i * samplesPerBar;
                    let end = Math.min(start + samplesPerBar, channelData.length);
                    
                    for (let j = start; j < end; j++) {
                        sum += Math.abs(channelData[j]);
                    }
                    
                    let average = sum / (end - start);
                    waveformData.push(Math.min(average * 100, 100));
                }
                
                waveform.innerHTML = '';
                currentWaveformBars = [];
                
                waveformData.forEach((height, index) => {
                    const bar = document.createElement('div');
                    bar.className = 'waveform-bar';
                    bar.style.height = `${Math.max(height, 2)}%`;
                    bar.style.flex = '1';
                    waveform.appendChild(bar);
                    currentWaveformBars.push(bar);
                });
                
            } catch (error) {
                console.error('Waveform generation error:', error);
                createFallbackWaveform();
            }
        }

        function createFallbackWaveform() {
            waveform.innerHTML = '';
            currentWaveformBars = [];
            
            for (let i = 0; i < 200; i++) {
                const bar = document.createElement('div');
                bar.className = 'waveform-bar';
                bar.style.height = `${Math.random() * 80 + 10}%`;
                bar.style.flex = '1';
                waveform.appendChild(bar);
                currentWaveformBars.push(bar);
            }
        }

        // Play/pause controls
        playBtn.addEventListener('click', () => {
            if (!currentSong) return;

            if (isPlaying) {
                audioPlayer.pause();
                isPlaying = false;
                playBtn.textContent = '‚ñ∂Ô∏è';
            } else {
                audioPlayer.play();
                isPlaying = true;
                playBtn.textContent = '‚è∏Ô∏è';
            }
        });

        // Update progress and waveform
        audioPlayer.addEventListener('timeupdate', () => {
            const currentTime = audioPlayer.currentTime;
            const duration = audioPlayer.duration;
            
            if (duration) {
                const progress = (currentTime / duration) * 100;
                progressOverlay.style.width = `${progress}%`;
                
                const activeBarIndex = Math.floor((currentTime / duration) * currentWaveformBars.length);
                currentWaveformBars.forEach((bar, index) => {
                    if (index <= activeBarIndex - 1) {
                        bar.classList.add('active');
                    } else {
                        bar.classList.remove('active');
                    }
                });
                
                timeInfo.textContent = `${formatTime(currentTime)} / ${formatTime(duration)}`;
            }
        });

        // Waveform click to seek
        waveformContainer.addEventListener('click', (e) => {
            if (!currentSong || !audioPlayer.duration) return;
            
            const rect = waveformContainer.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const percentage = clickX / rect.width;
            const seekTime = percentage * audioPlayer.duration;
            
            audioPlayer.currentTime = seekTime;
        });

        // Utility functions
        function showMessage(message, type) {
            const messageDiv = document.createElement('div');
            messageDiv.className = type;
            messageDiv.textContent = message;
            
            const targetSection = currentView === 'library' ? 
                document.querySelector('.upload-section') : 
                document.querySelector('.container');
            
            if (currentView === 'library') {
                targetSection.insertBefore(messageDiv, document.querySelector('.upload-area'));
            } else {
                targetSection.insertBefore(messageDiv, targetSection.firstChild);
            }
            
            setTimeout(() => {
                messageDiv.remove();
            }, 5000);
        }

        function formatFileSize(bytes) {
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            if (bytes === 0) return '0 Bytes';
            const i = Math.floor(Math.log(bytes) / Math.log(1024));
            return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + ' ' + sizes[i];
        }

        function formatDuration(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function formatDate(date) {
            return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
        }

        // Close modals when clicking outside
        document.addEventListener('click', (e) => {
            const modals = document.querySelectorAll('.modal.active');
            modals.forEach(modal => {
                if (e.target === modal) {
                    modal.classList.remove('active');
                }
            });
        });

        // Handle Enter key for playlist creation
        document.getElementById('playlistName').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                createPlaylist();
            }
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Space bar to play/pause (when not in input fields)
            if (e.code === 'Space' && !['INPUT', 'TEXTAREA'].includes(e.target.tagName)) {
                e.preventDefault();
                if (currentSong) {
                    playBtn.click();
                }
            }
            
            // Arrow keys for playlist navigation (when in playlist view)
            if (currentView === 'playlist' && currentPlaylistSongs.length > 0) {
                if (e.code === 'ArrowUp' && currentSongIndex > 0) {
                    e.preventDefault();
                    playPlaylistSong(currentSongIndex - 1);
                } else if (e.code === 'ArrowDown' && currentSongIndex < currentPlaylistSongs.length - 1) {
                    e.preventDefault();
                    playPlaylistSong(currentSongIndex + 1);
                }
            }
            
            // Escape key to close modals
            if (e.code === 'Escape') {
                const activeModals = document.querySelectorAll('.modal.active');
                activeModals.forEach(modal => modal.classList.remove('active'));
            }
        });

        // Update playlist view when songs are playing
        function updatePlaylistView() {
            if (currentView === 'playlist') {
                const songItems = document.querySelectorAll('.song-item');
                songItems.forEach((item, index) => {
                    if (index === currentSongIndex) {
                        item.classList.add('playing');
                    } else {
                        item.classList.remove('playing');
                    }
                });
            }
        }

        // Enhanced play function for playlist context
        const originalPlaySong = window.playSong;
        window.playSong = async (songIdOrData, title, isChunked = false) => {
            await originalPlaySong(songIdOrData, title, isChunked);
            updatePlaylistView();
        };

        // Initialize app
        loadSongs();

        // Service worker for offline functionality (optional enhancement)
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then((registration) => {
                        console.log('SW registered: ', registration);
                    })
                    .catch((registrationError) => {
                        console.log('SW registration failed: ', registrationError);
                    });
            });
        }

        // Add visual feedback for interactions
        function addRippleEffect(element, event) {
            const rect = element.getBoundingClientRect();
            const ripple = document.createElement('div');
            const size = Math.max(rect.width, rect.height);
            const x = event.clientX - rect.left - size / 2;
            const y = event.clientY - rect.top - size / 2;
            
            ripple.style.cssText = `
                position: absolute;
                width: ${size}px;
                height: ${size}px;
                left: ${x}px;
                top: ${y}px;
                background: rgba(168, 85, 247, 0.3);
                border-radius: 50%;
                transform: scale(0);
                animation: ripple 0.6s ease-out;
                pointer-events: none;
                z-index: 1;
            `;
            
            element.style.position = 'relative';
            element.style.overflow = 'hidden';
            element.appendChild(ripple);
            
            setTimeout(() => {
                ripple.remove();
            }, 600);
        }

        // Add ripple effect styles
        const style = document.createElement('style');
        style.textContent = `
            @keyframes ripple {
                to {
                    transform: scale(2);
                    opacity: 0;
                }
            }
            
            .song-card, .playlist-card, .btn, .nav-btn {
                position: relative;
                overflow: hidden;
            }
        `;
        document.head.appendChild(style);

        // Add ripple effect to clickable elements (but exclude playlist buttons)
        document.addEventListener('click', (e) => {
            // Don't add ripple to playlist control buttons
            if (e.target.closest('.add-to-playlist-btn, .delete-btn, .remove-from-playlist-btn')) {
                return;
            }
            
            const clickableElements = ['.song-card', '.playlist-card', '.btn', '.nav-btn'];
            const element = e.target.closest(clickableElements.join(', '));
            
            if (element) {
                addRippleEffect(element, e);
            }
        });

        // Performance optimization: Debounce search functionality
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Add search functionality (future enhancement placeholder)
        window.searchSongs = debounce((query) => {
            if (!query.trim()) {
                displaySongs(allSongs);
                return;
            }
            
            const filteredSongs = allSongs.filter(song => 
                song.title.toLowerCase().includes(query.toLowerCase()) ||
                song.filename.toLowerCase().includes(query.toLowerCase())
            );
            
            displaySongs(filteredSongs);
        }, 300);

        // Add drag and drop functionality for playlist reordering (future enhancement)
        let draggedSong = null;

        function enablePlaylistDragDrop() {
            if (currentView !== 'playlist') return;
            
            const songItems = document.querySelectorAll('.song-item');
            songItems.forEach((item, index) => {
                item.draggable = true;
                
                item.addEventListener('dragstart', (e) => {
                    draggedSong = { element: item, index: index };
                    item.style.opacity = '0.5';
                });
                
                item.addEventListener('dragend', (e) => {
                    item.style.opacity = '1';
                    draggedSong = null;
                });
                
                item.addEventListener('dragover', (e) => {
                    e.preventDefault();
                });
                
                item.addEventListener('drop', (e) => {
                    e.preventDefault();
                    if (draggedSong && draggedSong.index !== index) {
                        // Reorder playlist logic would go here
                        console.log(`Move song from index ${draggedSong.index} to ${index}`);
                    }
                });
            });
        }

        // Enhanced error handling and retry mechanisms
        async function retryOperation(operation, maxRetries = 3, delay = 1000) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    return await operation();
                } catch (error) {
                    if (i === maxRetries - 1) throw error;
                    await new Promise(resolve => setTimeout(resolve, delay * Math.pow(2, i)));
                }
            }
        }

        // Add loading states for better UX
        function setLoadingState(element, isLoading) {
            if (isLoading) {
                element.disabled = true;
                element.classList.add('loading-pulse');
                const originalText = element.textContent;
                element.dataset.originalText = originalText;
                element.textContent = 'Loading...';
            } else {
                element.disabled = false;
                element.classList.remove('loading-pulse');
                element.textContent = element.dataset.originalText || element.textContent;
            }
        }

        // Enhanced analytics and usage tracking (optional)
        function trackEvent(eventName, properties = {}) {
            // Analytics integration would go here
            console.log(`Event: ${eventName}`, properties);
        }

        // Track playlist interactions
        const originalCreatePlaylist = window.createPlaylist;
        window.createPlaylist = async () => {
            trackEvent('playlist_created');
            return await originalCreatePlaylist();
        };

        // Initialize drag and drop when playlist view loads
        const originalLoadPlaylistView = loadPlaylistView;
        loadPlaylistView = async (playlistId, playlistName) => {
            await originalLoadPlaylistView(playlistId, playlistName);
            setTimeout(enablePlaylistDragDrop, 100); // Small delay to ensure DOM is ready
        };

        console.log('soundsync loaded');
    </script>
</body>
</html>
